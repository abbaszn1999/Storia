/**
 * Audio-Video Synchronization Utility
 * 
 * Handles synchronized playback of video with separate audio track.
 * Used when audio is generated by ElevenLabs (model doesn't support native audio).
 */

export interface SyncedPlaybackOptions {
  /** Video element to control */
  videoElement: HTMLVideoElement;
  /** Audio URL (data URI or URL) */
  audioUrl: string;
  /** Volume level 0-1 (default: 1) */
  volume?: number;
  /** Callback when audio is loaded and ready */
  onAudioReady?: () => void;
  /** Callback on error */
  onError?: (error: Error) => void;
}

export interface SyncedPlaybackController {
  /** Play both video and audio */
  play: () => Promise<void>;
  /** Pause both video and audio */
  pause: () => void;
  /** Seek to specific time (seconds) */
  seek: (time: number) => void;
  /** Set volume (0-1) */
  setVolume: (volume: number) => void;
  /** Get current audio element */
  getAudioElement: () => HTMLAudioElement;
  /** Cleanup and destroy */
  destroy: () => void;
}

/**
 * Create a synchronized playback controller for video with separate audio
 * 
 * @example
 * ```typescript
 * const controller = createSyncedPlayback({
 *   videoElement: videoRef.current!,
 *   audioUrl: "data:audio/mpeg;base64,...",
 *   volume: 0.8,
 * });
 * 
 * await controller.play();
 * controller.pause();
 * controller.destroy();
 * ```
 */
export function createSyncedPlayback(
  options: SyncedPlaybackOptions
): SyncedPlaybackController {
  const { videoElement, audioUrl, volume = 1, onAudioReady, onError } = options;

  // Create audio element
  const audioElement = new Audio();
  audioElement.src = audioUrl;
  audioElement.volume = volume;
  audioElement.preload = "auto";

  let isReady = false;
  let isSeeking = false;

  // Handle audio loaded
  audioElement.addEventListener("canplaythrough", () => {
    isReady = true;
    onAudioReady?.();
  });

  // Handle audio errors
  audioElement.addEventListener("error", () => {
    const error = new Error("Failed to load audio");
    console.error("[audio-video-sync] Audio load error:", audioElement.error);
    onError?.(error);
  });

  // Sync video events to audio
  const handleVideoPlay = async () => {
    if (isReady && audioElement.paused) {
      try {
        await audioElement.play();
      } catch (err) {
        console.warn("[audio-video-sync] Audio play failed:", err);
      }
    }
  };

  const handleVideoPause = () => {
    if (!audioElement.paused) {
      audioElement.pause();
    }
  };

  const handleVideoSeeking = () => {
    isSeeking = true;
  };

  const handleVideoSeeked = () => {
    if (!isSeeking) return;
    isSeeking = false;
    audioElement.currentTime = videoElement.currentTime;
  };

  const handleVideoEnded = () => {
    audioElement.pause();
    audioElement.currentTime = 0;
  };

  // Keep audio in sync with video time (handles drift)
  const handleVideoTimeUpdate = () => {
    if (isSeeking) return;
    
    const drift = Math.abs(videoElement.currentTime - audioElement.currentTime);
    // Resync if drift is more than 0.3 seconds
    if (drift > 0.3) {
      audioElement.currentTime = videoElement.currentTime;
    }
  };

  // Attach event listeners
  videoElement.addEventListener("play", handleVideoPlay);
  videoElement.addEventListener("pause", handleVideoPause);
  videoElement.addEventListener("seeking", handleVideoSeeking);
  videoElement.addEventListener("seeked", handleVideoSeeked);
  videoElement.addEventListener("ended", handleVideoEnded);
  videoElement.addEventListener("timeupdate", handleVideoTimeUpdate);

  // Load audio
  audioElement.load();

  // Controller API
  const controller: SyncedPlaybackController = {
    async play() {
      if (!isReady) {
        console.warn("[audio-video-sync] Audio not ready yet");
      }
      
      // Sync time before playing
      audioElement.currentTime = videoElement.currentTime;
      
      // Play video (audio will follow via event listener)
      await videoElement.play();
    },

    pause() {
      videoElement.pause();
      audioElement.pause();
    },

    seek(time: number) {
      videoElement.currentTime = time;
      audioElement.currentTime = time;
    },

    setVolume(vol: number) {
      audioElement.volume = Math.max(0, Math.min(1, vol));
    },

    getAudioElement() {
      return audioElement;
    },

    destroy() {
      // Remove event listeners
      videoElement.removeEventListener("play", handleVideoPlay);
      videoElement.removeEventListener("pause", handleVideoPause);
      videoElement.removeEventListener("seeking", handleVideoSeeking);
      videoElement.removeEventListener("seeked", handleVideoSeeked);
      videoElement.removeEventListener("ended", handleVideoEnded);
      videoElement.removeEventListener("timeupdate", handleVideoTimeUpdate);

      // Clean up audio
      audioElement.pause();
      audioElement.src = "";
      audioElement.remove();
    },
  };

  return controller;
}

/**
 * React hook for synchronized video-audio playback
 * 
 * @example
 * ```typescript
 * const { audioReady, controller } = useSyncedPlayback(videoRef, audioUrl);
 * 
 * // Use controller.play(), controller.pause(), etc.
 * ```
 */
export function useSyncedPlaybackEffect(
  videoRef: React.RefObject<HTMLVideoElement>,
  audioUrl: string | null | undefined,
  volume: number = 1
): {
  isAudioReady: boolean;
  controller: SyncedPlaybackController | null;
} {
  // This is just a type definition helper for the hook
  // Actual implementation would use React hooks
  return {
    isAudioReady: false,
    controller: null,
  };
}

